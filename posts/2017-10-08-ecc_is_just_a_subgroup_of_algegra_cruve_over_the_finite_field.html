<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Ryan's Cave - 2017-10-08-ecc_is_just_a_subgroup_of_algegra_cruve_over_the_finite_field</title>
        <script type="text/javascript" src="../js/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML-full,Safe"></script>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/github.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Ryan's Cave</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <div class="info">
    Posted on October  8, 2017
    
</div>

<h1 id="the-elliptic-curves-group">The Elliptic Curves Group</h1>
<h1 id="pubic-key-cryptography">Pubic-key cryptography</h1>
<p>“The mathematics of public-key cryptography uses a lot of group theory. Different cryptosystems use different groups, such as the group of units in modular arithmetic and the group of rational points on elliptic curves over a finite field. This use of group theory derives not from the “symmetry” perspective, but from the efficiency or difficulty of carrying out certain computations in the groups. Other public-key cryptosystems use other algebraic structures, such as lattices.”’<span class="citation"></span></p>
<h2 id="definition">Definition<span class="citation"></span></h2>
<p>A set <span class="math inline">\(\mathbb{G}={a, b, c, ...}\)</span> is called a group, if tehere exists a group addition <span class="math inline">\((+)\)</span> connecting the elements in <span class="math inline">\((\mathbb{G}, +)\)</span> in the following way:</p>
<p>(1) <span class="math inline">\(a, b \in \mathbb{G}:\ c=a+b \in \mathbb{G}\)</span> (closure)</p>
<p>(2) <span class="math inline">\(a, b, c \in \mathbb{G}: (a+b)c=a(b+c)\)</span> (associativity)</p>
<p>(3) <span class="math inline">\(\exists e \in \mathbb{G}: a+e=e, \forall a \in \mathbb{G}\)</span> (identity / neutral element)</p>
<p>(4) <span class="math inline">\(\forall a \in \mathbb{G}, \exists b \in \mathbb{G}: a+b=e, i.e., b\equiv -a\)</span> (inverse)</p>
<p>if a group obey axiom (1,2), it is a SemiGroup;</p>
<p>if a group obey axiom (1,2,3), it is a monadid;</p>
<p>if a group obey axiom (1,2,3,4) and the axiom of commutatativity(<span class="math inline">\(a+b=b+a\)</span>), it is a Abelian Group</p>
<h2 id="abstract-implementation-of-groups">Abstract Implementation of Groups</h2>
<pre title="abstract.py"><code>
class Groupoid(metaclass=ABCMeta):

    __slots__ = ()

    def __init__(self, v):
        self.value = v

    @abstractmethod
    def op(self, g: 'Group') -&gt; 'Group':
        pass

    def __eq__(self, b) -&gt; bool:
        return self.value == b.value

    def __add__(self, g: 'Group') -&gt; 'Group':
        assert isinstance(g, type(self))
        res = self.op(g)
        assert isinstance(res, type(self))
        return res

    def __repr__(self):
        return &quot;%s::%s&quot; % (
            type(self).__name__,
            self.value
        )

    def __str__(self):
        return str(self.value)


class SemiGroup(Groupoid):

    __slots__ = ()

    @abstractmethod
    def op(self, g: 'Group') -&gt; 'Group':
        '''
        The Operator for obeying axiom `associativity` (2)
        '''
        pass


class Monoid(SemiGroup):
    __slots__ = ()

    @abstractproperty
    def identity(self):
        '''
        The value for obeying axiom `identity` (3)
        '''
        pass

    def __matmul__(self, n):
        return double_and_add_algorithm(
            getattr(n, 'value', n), self, self.identity)


class Group(Monoid):
    __slots__ = ()

    @abstractmethod
    def inverse(self, g: 'Group') -&gt; 'Group':
        '''
        Implement for axiom `inverse`
        '''
        pass

    def __sub__(self, g: 'Group') -&gt; 'Group':
        '''
        Allow to reverse op via a - b
        '''
        return self.op(g.inverse())

    def __neg__(self) -&gt; 'Group':
        return self.inverse()</code></pre>
<h2 id="concrete-ec-group">Concrete EC Group</h2>
<pre><code>  
class EllipticCurveGroup(Group):
    # for y^2 = x^3 + A * x + B
    A = abstractproperty()
    B = abstractproperty()

    def op(self, g):
        if g.value == 0:
            return self
        field = self.value[0].__class__

        if self.value[0] != g.value[0]:
            m = (self.value[1] - g.value[1]) / (self.value[0] - g.value[0])
        if self.value[0] == g.value[0]:
            m = (field(3) * self.value[0] * self.value[0] +
                 field(self.A)) / (field(2) * self.value[1])
        r_x = (m * m - self.value[0] - g.value[0])
        r_y = (self.value[1] + m * (r_x - self.value[0]))
        return self.__class__((r_x, -r_y))

    def inverse(self):
        return self.__class__((self.value[0], -self.value[0]))

    @property
    def identity(self):
        # The abstract zero of EC Group
        return self.__class__(0)</code></pre>
<h1 id="the-finite-field">The Finite Field</h1>
<h2 id="definition-1">Definition</h2>
<p>A field is any set of elements that satisfies the field axioms for both addition and multiplication and is a commutative division algebra.</p>
<p>Field Axioms<span class="citation"></span> are generally written in additive and multiplication pairs:</p>
<p>(1) <span class="math inline">\((a+b)+c=a+(b+c)\)</span>; <span class="math inline">\((a b) c = a(b c)\)</span> (associativity)</p>
<p>(2) <span class="math inline">\(a + b = b + a\)</span>; <span class="math inline">\( a b = b a\)</span> (Commutativity)</p>
<p>(3) <span class="math inline">\(a(b+c) = ab + ac\)</span>; <span class="math inline">\((a+b)c=ac+bc\)</span> (distributivity)</p>
<p>(4) <span class="math inline">\(a + 0=a=0+1\)</span>; <span class="math inline">\((a.1=a=1.a)\)</span> (identity)</p>
<p>(5) <span class="math inline">\(a+(-a)=0=(-a)+a\)</span>; <span class="math inline">\(aa^{-1}=1=a^{-1}a if a \neq 0\)</span> (inverses)</p>
<h2 id="abstract-implementation-of-fields">Abstract Implementation of Fields</h2>
<pre><code>

class Field(Group):
    __slots__ = ()

    @abstractmethod
    def sec_op(self, g: 'Group') -&gt; 'Group':
        '''
        The Operator for obeying axiom `associativity` (2)
        '''
        pass

    @abstractmethod
    def sec_inverse(self) -&gt; 'Group':
        '''
        Implement for axiom `inverse`
        '''
        pass

    @abstractmethod
    def sec_identity(self):
        pass

    def __invert__(self):
        return self.sec_inverse()

    def __mul__(self, g: 'Group') -&gt; 'Group':
        '''
        Allowing call associativity operator via A * B
        Strict limit arg `g` and ret `res` should be subtype of Group,
        For obeying axiom `closure` (1)
        '''
        res = self.sec_op(g)
        assert isinstance(res, type(self)), 'result shuould be %s' % type(self)
        return res

    def __truediv__(self, g: 'Group') -&gt; 'Group':
        return self.sec_op(g.sec_inverse())</code></pre>
<h2 id="the-finite-field-1">The Finite Field</h2>
<p>A finite field is, A set with a finite number of elements. An example of inite field is the set of integers modulo <span class="math inline">\(p\)</span>, where <span class="math inline">\(p\)</span> is a prime number, which can be generally note as <span class="math inline">\(\mathbb{Z}/p\)</span>, <span class="math inline">\(GF(p)\)</span> or <span class="math inline">\(\mathbb{F}_p\)</span>.</p>
<h2 id="implementation-of-finite-field">Implementation of Finite Field</h2>
<pre><code>  
class FiniteField(Field):

    P = abstractproperty()

    @property
    def identity(self):
        return self.__class__(0 % self.P)

    @property
    def sec_identity(self):
        return self.__class__(1 % self.P)

    def inverse(self):
        return self.__class__(-self.value % self.P)

    def sec_inverse(self):
        gcd, x, y = extended_euclidean_algorithm(self.value, self.P)
        assert (self.value * x + self.P * y) == gcd
        if gcd != 1:
            # Either n is 0, or p is not prime number
            raise ValueError(
                '{} has no multiplicate inverse '
                'modulo {}'.format(self.value, self.P)
            )
        return self.__class__(x % self.P)

    def op(self, n):
        return self.__class__((self.value + n.value) % self.P)

    def sec_op(self, n):
        return self.__class__((self.value * n.value) % self.P)</code></pre>
<h1 id="finite-field-functor">Finite Field Functor</h1>
<h2 id="definition-of-category">Definition of Category</h2>
<p>There are three laws that categories need to follow:</p>
<p>(1) if <span class="math inline">\(f: \rightarrow b, g: b \rightarrow c\ and\ h: c \rightarrow d\ then\ h \circ (g\circ f)=(h\circ g)\circ f\)</span> (associativity)</p>
<p>(2) <span class="math inline">\(\forall object_x,\exists morphism 1_x: x \rightarrow x\)</span> such as <span class="math inline">\(\forall morphism\ f:a\rightarrow b: \exists 1_b \circ f=f=f\circ 1_a\)</span> (identity)</p>
<p>(3) if <span class="math inline">\(f: B \rightarrow C\ and\ g: A \rightarrow B: h: A \rightarrow C\)</span> such that <span class="math inline">\(h=f \circ g\)</span> (closed under the composition operation)</p>
<h2 id="functor-of-finite-field">Functor of Finite Field</h2>
<p>In mathematics, a functor is a type of mapping between categories arising in category theory. Functors can be thought of as homomorphisms between categories. In the category of small categories, functors can be thought of more generally as morphisms.<span class="citation"></span></p>
<p>Thus, when discussing about Integer Field and Prime Finite Field, we can simply redefined the implementation of Finite Field above as a Functor which defined <span class="math inline">\(int \rightarrow Finite Prime Set\)</span> as <span class="math inline">\(fmap\)</span>.</p>
<h1 id="composed">Composed</h1>
<h2 id="scala-multiplication">Scala Multiplication</h2>
<p>For reasoning the subgroup of EC Group, we introduce the scala multiplication here. The Scala Multiplication can be easily implement with ’Double as Multi Alogorithm’ like this:</p>
<pre><code>  
def double_and_add_algorithm(n, x, init):
    &quot;&quot;&quot;
    Returns the result of n * x, computed using
    the double and add algorithm.
    &quot;&quot;&quot;
    def bits(n):
        &quot;&quot;&quot;
        Generates the binary digits of n, starting
        from the least significant bit.
        bits(151) -&gt; 1, 1, 1, 0, 1, 0, 0, 1
        &quot;&quot;&quot;
        while n:
            yield n &amp; 1
            n &gt;&gt;= 1

    result = init
    addend = x

    for bit in bits(n):
        if bit == 1:
            result = addend + result
        addend = addend + addend

    return result


def schoof_algorithm(p, a, b):
    return p + 1 - frobenius_trace(EllipticCurve(FiniteField(p), a, b))

  </code></pre>
<p>And we can add the property to the <span class="math inline">\(Monoid\)</span>, and denoted with symbol <span class="math inline">\(@\)</span>.</p>
<pre><code>
class Monoid(SemiGroup):
    __slots__ = ()

    @abstractproperty
    def identity(self):
        '''
        The value for obeying axiom `identity` (3)
        '''
        pass

    def __matmul__(self, n):
        return double_and_add_algorithm(
            getattr(n, 'value', n), self, self.identity)


  </code></pre>
<h2 id="group-over-finite-field">Group over Finite Field</h2>
<p>With the Functor of Finite Field, we can easily calculate the ECG over Finite Fields like this.</p>
<pre><code>a = EllipticCurveGroupN710((FiniteField97(11), (FiniteField97(10))))
b = EllipticCurveGroupN710((FiniteField97(87), (FiniteField97(27))))
res = EllipticCurveGroupN710((FiniteField97(74), (FiniteField97(41))))
assert (a + b) == res</code></pre>
<h2 id="subgroup">SubGroup</h2>
<p>And by researching about the ECG over Finite Field, we can easily find out the Scala Multiplication on it is actually a subgroups (the <span class="math inline">\(+\)</span> between <span class="math inline">\(nP\)</span> always obey the <span class="math inline">\(closure rule.\)</span>)</p>
<pre><code>  def test_cyclic_subgroup():
    a = EllipticCurveCyclicSubgroup36(1)
    b = EllipticCurveCyclicSubgroup36(2)
    assert a + b == EllipticCurveCyclicSubgroup36(3)
    assert EllipticCurveGroup0203(
        (FiniteField97(3), FiniteField97(6))
    ) @ (a + b) == EllipticCurveGroup0203(
        (FiniteField97(80), FiniteField97(87))
    )
    a = EllipticCurveCyclicSubgroup36(1)
    b = EllipticCurveCyclicSubgroup36(6)

    assert EllipticCurveGroup0203(
        (FiniteField97(3), FiniteField97(6))
    ) @ (a + b) == EllipticCurveGroup0203(
        (FiniteField97(80), FiniteField97(10))
    )

    a = EllipticCurveCyclicSubgroup36(1)
    b = EllipticCurveCyclicSubgroup36(9)

    assert EllipticCurveGroup0203(
        (FiniteField97(3), FiniteField97(6))
    ) @ (a + b) == EllipticCurveGroup0203(0)</code></pre>
<p><span>9</span> Roland Winkler, Aug 2011, Introduction to Group Theory, http://niu.edu/rwinkler/teaching/group-11/g-lecture.pdf Why is group theory important, http://www.math.uconn.edu/ kconrad/math216/whygroups.html Bartosz Milewski, Category Theory for Programmers, https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/ Wikipedia, Category Theory, https://en.wikipedia.org/wiki/Haskell/Category_theory Wikibooks/Haskell, Category Theory, https://en.wikibooks.org/wiki/Haskell/Category_theory</p>
<p>Weisstein, Eric W. “Field Axioms.” From MathWorld–A Wolfram Web Resource. http://mathworld.wolfram.com/FieldAxioms.html</p>
<p>Wikipedia, Functor, https://en.wikipedia.org/wiki/Functor</p>

        </div>

        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
